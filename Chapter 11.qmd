---
title: "Chapter 11"
format: html
editor: visual
---

# Color scales and legends

Imports

```{r}
#| echo: false
library(tidyverse)
library(patchwork)
```

## 11.1 A little color theory

This is geared towards the perception of sensory input to the eyes, which can be complex and is explained well http://tinyurl.com/clrdtls. There's the usual RGB encoding of color space, which defines a color by the intesities of red, green, and blue light needed to produce it. However a modern approach is used that uses HCL color space of *h*ue, *c*hroma, and *l*uminance. - *Hue* ranges from 0 to 360 (an angle) and gives the 'color' of the color. - *Chroma* is the 'purity' of the color, ranging from 0 (grey) to a maximum that varies with luminance - *Luminance* is the lightness of the color, ranging from 0 (black) to 1 (white).

### 11.1.1 Color blindness

A sizeable minority of people do not posess the usual complemnt of color receptions and so can distinguish fewer colros than others. A simple heuristic is to avoid red-green contrasts, and there's ways to check that visuals are easy to read for color-blind individuals (https://www.vischeck.com/). The `displayAllColors()` function from the *colorBlindness* package.

```{r}
#| warning: false
colorBlindness::displayAllColors(rainbow(6))
```

The quick and easy `viridis()` colorscale are discriminable under the most common forms of color blindness and greyscale.

```{r}
#| warning: false
colorBlindness::displayAllColors(viridis::viridis(6))
```

## 11.2 Continuous color scales

Example plot for the section. Note that the fill aesthetic is used by the color aesthetic has the same ideas applied.

```{r}
erupt <- ggplot(faithfuld, aes(waiting,eruptions, fill=density)) +
  geom_raster() +
  scale_x_continuous(NULL,expand=c(0,0)) +
  scale_y_continuous(NULL,expand=c(0,0)) +
  theme(legend.position = 'none')

```

### 11.2.1 Particular palettes

**ggplot2** has some "hand picked" palettes available. Such as `scale_fill_viridis_c()` (c for continuous)

```{r}
#| layout-ncol: 3
#| fig-width: 3
#| fig-height: 3
erupt
erupt + scale_fill_viridis_c()
erupt + scale_fill_viridis_c(option = 'magma')
```
Or `scale_fill_distiller()`
```{r}
#| layout-ncol: 3
#| fig-width: 3
#| fig-height: 3
erupt + scale_fill_distiller()
erupt + scale_fill_distiller(palette = 'RdPu')
erupt + scale_fill_distiller(palette = 'YlOrBr')
```
Or *scico* package for other palettes that are perpectually uniform and suitable for scientific visualization
```{r}
#| layout-ncol: 3
#| fig-width: 3
#| fig-height: 3
erupt + scico::scale_fill_scico(palette = 'bilbao') # default
erupt + scico::scale_fill_scico(palette = 'vik')
erupt + scico::scale_fill_scico(palette = 'lajolla')
```
And lastly my recommended palette package *paletteer* which combines everything shown. 
```{r}
#| layout-ncol: 3
#| fig-width: 3
#| fig-height: 3

erupt + paletteer::scale_fill_paletteer_c('viridis::plasma')
erupt + paletteer::scale_fill_paletteer_c('scico::tokyo')
```
### 11.2.2 Robust recipes
These return the same plot. 
```{r}
#| layout-ncol: 3
#| fig-width: 3
#| fig-height: 3

erupt 
erupt + scale_fill_continuous()
erupt + scale_fill_gradient()
```
Gradient scales provide a robust method for creating any color scheme you like. You just specify two or more reference colors and *ggplot2* will interpolate linearly between them. 
- `scale_fill_gradient()` produces a two-color gradient
- `scale_fill_gradient2()` produces a three-color gradient with specified midpoint
- `scale_fill_gradientn()` produces an n-color gradient. 
```{r}
#| layout-ncol: 3
#| fig-width: 3
#| fig-height: 3

erupt + scale_fill_gradient(low='grey',high='brown')
erupt +
  scale_fill_gradient2(
    low = 'grey',
    mid = 'white',
    high = 'brown',
    midpoint = 0.02 # Value at which to set midpoint to (default=0)
  )
erupt + scale_fill_gradientn(colors = terrain.colors(7))
```
Gradient color palettes require a bit more thought. Generally, for a two-point gradient scale you want to convey the perceptual impression that the values are sequentially ordered, so you want to keep hue constant, and vary chroma and luminance. The Munsell color system is useful for this as it proivides an easy way of specifying colros based on their hue, chroma, and luminance. Accessed through the *munsell* package (https://github.com/cwickham/munsell/). 
```{r}
#| layout-ncol: 2
#| fig-width: 3
#| fig-height: 3
#| warning: false

# Generate plot with hue_slice to see colors (annotating the column we choose)
munsell::hue_slice('5P') +
  annotate(
    geom = 'segment',
    x = c(7,7),
    y = c(1,10),
    xend = c(7,7),
    yend = c(2,9),
    arrow = arrow(length = unit(2,'mm')) 
  )

# Build figure
erupt + scale_fill_gradient(
  low = munsell::mnsl('5P 2/12'),
  high = munsell::mnsl('5P 7/12')
)

```
n-point gradient is good if you want to try to map the colors to the context of the figure. So if green/blue/whatever color is supposed to mean something to the audience then you can easily pick a color range that's best for it. 
```{r}
#| layout-ncol: 3
#| fig-width: 3
#| fig-height: 3
#| warning: false

# munsell example
erupt + scale_fill_gradient2(
  low = munsell::mnsl("5B 7/8"),
  high = munsell::mnsl("5Y 7/8"),
  mid = munsell::mnsl("N 7/0"),
  midpoint = .02
) 

# colorspace examples
erupt + scale_fill_gradientn(colours = colorspace::heat_hcl(7))
erupt + scale_fill_gradientn(colours = colorspace::diverge_hcl(7))
```
### 11.2.3 Missing values
All continuous color scales have an `na.value` parameter that controls what color is used for missing values (including values outside of the range of scale limits). Setting `na.value=NA` makes missing values invisible. 
```{r}
#| layout-ncol: 3
#| fig-width: 3
#| fig-height: 3
#| warning: false
#| 
df <- tibble(x= 1,y=1:5,z=c(1,3,2,NA,5))
base <- ggplot(df,aes(x,y))+
  geom_tile(aes(fill=z),linewidth = 5) +
  labs(x=NULL,y=NULL) +
  scale_x_continuous(labels=NULL)

base
base + scale_fill_gradient(na.value = NA)
base + scale_fill_gradient(na.value = 'yellow')

```
### 11.2.4 Limits, breaks, and labels
```{r}
#| layout-ncol: 2
#| fig-width: 3
#| fig-height: 3

toy <- data.frame(
  const = 1, 
  up = 1:4,
  txt = letters[1:4], 
  big = (1:4)*1000,
  log = c(2, 5, 10, 2000)
)

base <- ggplot(toy, aes(up,up, fill = big)) +
  geom_tile() +
  labs(x=NULL,y=NULL)

base
base + scale_fill_continuous(limits = c(0,10000))
```
```{r}
#| layout-ncol: 2
#| fig-width: 3
#| fig-height: 3

base + scale_fill_continuous(breaks = c(1000,2000,4000)) # Can supress breaks entirely by setting them to NULL
base + scale_fill_continuous(labels = scales::label_dollar())
```

