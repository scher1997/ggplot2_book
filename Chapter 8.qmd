---
title: "Chapter 8"
format: html
editor: visual
---

# Annotations
Imports
```{r}
#| echo: false
library(tidyverse)
```

## 8.1 Plot and axis titles
`labs(title = My Title,x ='X Axis',y ='Y Axis,fill = 'fill legend')` 
```{r}
ggplot(mpg,aes(displ,hwy))+
  geom_point(aes(color=factor(cyl)))+
  labs(
    x = 'Engine displacement (liters)',
    y = 'Highway miles per gallon',
    color = 'Number of cylinders',
    title = 'Mileage by engine size and cylinders',
    subtitle = 'Source: https://fueleconomy.gov'
  )

```
Use `\n` to specify line break. Mathematical expressions also work within `quote()`. The details for math expressions are in ?plotmath() 
```{r}
values <- seq(from = -2, to = 2, by= 0.1)
df <- tibble(x=values,y=values^3)
ggplot(df,aes(x,y))+
  geom_path()+
  labs(y=quote(f(x)==x^3))
```
There's also a **ggtext** package for markdown in axis and legend titles. 
```{r}
df <- tibble(x=1:3,y=2:4)
ggplot(df,aes(x,y))+
  geom_point()+
  labs(x='Axis title with *italics* and **boldface**')+
  theme(axis.title.x = ggtext::element_markdown())
```
## 8.2 Text labels
`geom_text()` adds `label` text at the specified `x` and `y` positions. 
- The `family` aesthetic provides the name of a font. The aesthetic *does* allow the use of the name of a system font. There are three main fonts: "sans", "serif", or "mono" with "sans" as the default. 
```{r}
df <- tibble(x=1,y=3:1,family=c('sans','serif','mono'))
ggplot(df,aes(x,y))+
  geom_text(aes(label=family,family=family))
```

- The `fontface` aesthetic specifies the face, and can take three values: "plain" (default), 'bold', or 'italic'. 
```{r}
df <- tibble(x=1,y=3:1,face=c('plain','bold','italic'))
ggplot(df,aes(x,y))+
  geom_text(aes(label=face,fontface=face))
```
- Horizontal alignment `hjust` ('left','center','right','inward','outward') and vertical alignment `vjust` ('bottom','middle,'top','inward','outward'). 'inward' is useful because it guarantees the text remains within the plot. 
```{r}
df <- tibble(x=c(1,1,2,2,1.5),y=c(1,2,1,2,1.5),text=c('bottom-left','top-left','bottom-right','top-right','center'))
ggplot(df,aes(x,y))+
  geom_text(aes(label=text),vjust='inward',hjust='inward')
```
- Font size controlled by `size` in millimeters. 
- How to rotate text is through `angle`.

`geom_text()` has three parameters too. They're parameters because they only take single values (same for all labels).
1) `nudge_x` 
2) `nudge_y`
```{r}
df <- tibble(treatment = c('a','b','c'),response = c(1.2,3.4,2.5))
ggplot(df,aes(treatment,response))+
  geom_point()+
  geom_text(aes(label=paste0('(',response,')')),
            nudge_x = -0.3)+
  ylim(1.1,3.6)
```
3) `check_overlap` (boolean) to check if overlapping labels should be removed from the plot. Labels are plotted in the order they appear in the data. AKA if a "new" point overlaps with an existing point, then it is omitted. 
```{r}
ggplot(mpg,aes(displ,hwy))+
  geom_text(aes(label=model),check_overlap = TRUE) # Set to FALSE to see issue

```
`geom_label()` is simlar to `geom_text()` but with a rounded rectangle behind the text. 
```{r}
label <- tibble(waiting = c(55,80),eruptions = c(2,4.3),label=c('peak one','peak two'))
ggplot(faithfuld,aes(waiting, eruptions))+
  geom_tile(aes(fill=density))+
  geom_label(data=label,aes(label=label))
```
### 8.2.1 Text label notes
Labeling many points and setting `check_overlap = TRUE` does not always work well since it does not easily control which labels are removed. The **ggrepel** package includes `geom_text_repel()` which optimizes the label positions to avoid overlap. 
```{r}
mini_mpg <- mpg[sample(nrow(mpg),20),]
ggplot(mpg,aes(displ,hwy))+
  geom_point(color='red')+
  ggrepel::geom_text_repel(data=mini_mpg,aes(label=class))
```
Another issue is getting the text to fit within the space, which is easier to navigate by using the **ggfittext** package (https://github.com/wilkox/ggfittext). 
## 8.3 Building custom annotations
Several tools exist within **ggplot2** to annotate plots. 
- `geom_text()` and `geom_label()`
- `geom_rect()` to highlight interesting rectangular regions with aesthetics `xmin`, `xmax`, `ymin`, and `ymax`. 
- `geom_line()`, `geom_path()`, and `geom_segment()` to add lines with an `arrow` parameter to oplace an arrowhead on the line. Create arrowheads with `arrow(angle,length,ends,type)`
- `geom_vline()`, `geom_hline()`, and `geom_abline()` to add reference lines. 
Example is plotting US unemployment over time with annotations for each president during each time period. 
```{r}
presidential <-  subset(presidential,start>economics$date[1])

ggplot(economics)+
  geom_rect(
    aes(xmin = start, xmax=end,fill=party),
    ymin=-Inf,ymax=Inf,alpha = 0.2, # Top and bottom limits of the plot
    data=presidential
  ) +
  geom_vline(
    aes(xintercept=as.numeric(start)),
    data=presidential,
    color='grey', alpha = 0.5,
  ) +
  geom_text(
    aes(x=start,y=2500,label=name),
    data=presidential,
    size=3,vjust=0,hjust=0,nudge_x=50
  ) +
  geom_line(aes(date,unemploy))+
  scale_fill_manual('Political Party',values=c('blue','red'))+
  xlab('Date')+
  ylab('Unemployment')
```
`annotate()` helper function helps to add a single annotation. 
```{r}
yrng <- range(economics$unemploy)
xrng <- range(economics$date)
caption <- paste(strwrap("Unemployment rates in the US have 
  varied a lot over the years", 40), collapse = "\n")

ggplot(economics, aes(date, unemploy)) + 
  geom_line() + 
  annotate(
    geom = "text", x = xrng[1], y = yrng[2], 
    label = caption, hjust = 0, vjust = 1, size = 4
  )
```
To highlight a subset of points, a method is to draw larger points in a different color underneath the original set. 
```{r}
p <- ggplot(mpg,aes(displ,hwy))+
  geom_point(
    data=filter(mpg,manufacturer=='subaru'), # get highlighted points
    color='orange', # highlight points
    size=3
  ) + 
  geom_point()

p +
  annotate(geom='point',x = 5.5,y=40, color='orange', size=3) + # Add in orange legend point
  annotate(geom='point', x=5.5,y=40) + # Black point
  annotate(geom = 'text',x=5.6,y=40, label='Subaru',hjust='left') # Text
```
Then there are other clever ideas such as drawing arrows using `geom_curve()` and `geom_segment()` with `annotate()`. 
```{r}
p + 
  annotate(
    geom = 'curve', x= 4, y=35, xend= 2.65, yend = 27, size = 0.75,
    curvature = 0.3, arrow = arrow(length = unit(2,'mm'))
  ) +
  annotate(geom = 'text', x=4.1, y = 35, label = 'Subaru',hjust='left')
```
## 8.4 Direct labelling
The previous two plots are examples of "direct labelling", which the plot region itself contains the labels for groups of points instead of a legend. There are automated tools for this such as the **directlabels** package (http://directlabels.r-forge.r-project.org/). 
```{r}
ggplot(mpg,aes(displ,hwy,color=class))+
  geom_point(show.legend = FALSE)+
  directlabels::geom_dl(aes(label=class),method='smart.grid')
```
There is also the **ggforce** package (https://github.com/thomasp85/ggforce) which contains ideas such as the `geom_mark_ellipse()` which overlays an ellipse over the grouping of interest. 
```{r}
ggplot(mpg,aes(displ,hwy))+
  geom_point()+
  ggforce::geom_mark_ellipse(aes(label=cyl,group=cyl))
```
Finally there is the **gghighlight** package (https://github.com/yutannihilation/gghighlight) for highlighting points or lines. Think of longitudinal data. 
```{r}
data(Oxboys,package='nlme')
ggplot(Oxboys,aes(age,height,group=Subject))+
  geom_line()+
  geom_point()+
  gghighlight::gghighlight(Subject %in% 1:3) # Groups 1 to 3
```
## 8.5 Annotation across facets
Easier to see difference between the facets when you include the line (see the "shift" occuring as you move up in cut).
```{r}
# Get linear regression line
mod_coef <- coef(lm(log10(price)~log10(carat),data=diamonds))
ggplot(diamonds,aes(log10(carat),log10(price)))+
  geom_bin2d()+
  geom_abline(intercept = mod_coef[1],slope = mod_coef[2], color='white',linewidth=1)+
  facet_wrap(~cut,nrow=1)

```
To facet the same thing on each plot but highlight a different group (i.e. just the group of interest is highlight but the rest is in the background). 
```{r}
ggplot(mpg,aes(displ,hwy,color=factor(cyl)))+
  geom_point() +
  gghighlight::gghighlight() +
  labs(color = '# Cylinders',x='Engine displacement',y='Hwy miles per gallon') +
  facet_wrap(~cyl)+
  cowplot::theme_half_open() +
  theme(
    axis.title = element_text(hjust=0.5),
    legend.position = 'none',
    axis.line = element_line(arrow=arrow(length=unit(3,'mm'))),
    strip.background = element_rect(fill='white')
  )
  
```
## 8.6 Chapter Example
My own example to test a few things learned from the chapter. I'm thinking of looking at the unemployment data and maybe adding a few annotations for interest rate changes if that data is available?
```{r}
unemploy_rate <- read_csv('unemployment_rate.csv')
interest_rate <- read_csv('interest_rate.csv')
df <- inner_join(unemploy_rate,interest_rate,by='DATE') |> 
  rename(c(date = DATE, unemp_rate = UNRATE, int_rate = INTDSRUSM193N))


find_peaks <- function(x) {
  x_minus <- lag(x)
  x_plus <- lead(x)
  peaks <- x > x_minus & x > x_plus
  return(peaks)
}

interest_rate_changes <- df |> 
  filter(int_rate != lag(int_rate)) |> # Only if there's a change
  mutate(peaks = find_peaks(int_rate)) |> # Detect if this is a peak
  filter(peaks==TRUE)

interest_rate_changes
ggplot(df,aes(x=date,y=unemp_rate))+
  geom_path()+
  geom_label(data=interest_rate_changes,aes(x=date,y=unemp_rate,label=int_rate),nudge_y=1,color='green')+
  labs(x='Date',y='Unemployment Rate',title='Unemployment rate with peak interest rates over time ')+
  cowplot::theme_cowplot()

```

```{r}
# Custom function to find peaks
find_peaks <- function(x) {
  x_minus <- lag(x)
  x_plus <- lead(x)
  peaks <- x > x_minus & x > x_plus
  return(peaks)
}

# Example dataframe (replace with your actual data)
my_data <- data.frame(
  time = 1:10,
  values = c(10, 15, 12, 20, 18, 25, 22, 30, 28, 15)
)

# Add a new column for peaks
my_data <- my_data %>%
  mutate(peaks = find_peaks(values))

# View the modified dataframe
my_data

```


