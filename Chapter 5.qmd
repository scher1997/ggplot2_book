---
title: "Chapter 5"
format: html
editor: visual
---

# Chapter 5 Statistical summaries

Imports

```{r}
#| echo: false
library(tidyverse)
library(gridExtra) # multiplots
library(ggtext)

```

## 5.1 Revealing uncertainty

There are four basic families of geoms that can be used to show uncertainty, depending on whether the x values are discrete or continuous, and whether or not to display the middle of the interval or display the middle with extensions.

-   Discrete x, range: `geom_errorbar()`, `geom_linerange()`

-   Discrete x, range & center: `geom_crossbar()`, `geom_pointrange()`

-   Continuous x, range: `geom_ribbon()`

-   Continuous x, range & center: `geom_smooth(stat = 'identity')`

```{r}
y <- c(18,11,16)
df <- data.frame(x=1:3, y=y,se=c(1.2,0.5,1.0))

base <- ggplot(df,aes(x,y,ymin=y-se,ymax=y+se))
base + geom_crossbar()
base + geom_pointrange()
base + geom_smooth(stat='identity')
```

No middle.

```{r}
base+geom_errorbar()
base+geom_linerange()
base+geom_ribbon()
```

## 5.2 Weighted data

When you have aggregated data and each row represents multiple observations so you need to take into account the weighting variable. Data of interest is on midwest states and has some demographics in percentages and some info for each county.

Some things to weight by include:

-   Nothing to look at numbers of counties.

-   Total population to work with absolute numbers

-   Area to investigate geographic effects

```{r}
# Unweighted
ggplot(midwest, aes(percwhite, percbelowpoverty))+
  geom_point()

# Weight by population
ggplot(midwest, aes(percwhite, percbelowpoverty))+
  geom_point(aes(size=poptotal/1e6))+
  scale_size_area('Populations\n(millions)',breaks=c(0.5,1,2,4))

```

For more complicated geoms which involve some statistical transformation we use the `weight` aesthetic to specify weights. Weights are part of the statistical summary function and are used in smoothers, quantile regressions, boxplots, histograms, and density plots.

So when doing a linear model based on the data

```{r}
# Unweighted
ggplot(midwest, aes(percwhite, percbelowpoverty)) + 
  geom_point() + 
  geom_smooth(method = lm, linewidth = 1)
#> `geom_smooth()` using formula = 'y ~ x'

# Weighted by population
ggplot(midwest, aes(percwhite, percbelowpoverty)) + 
  geom_point(aes(size = poptotal / 1e6)) + 
  geom_smooth(aes(weight = poptotal), method = lm, linewidth = 1) +
  scale_size_area(guide = "none")
#> `geom_smooth()` using formula = 'y ~ x'
```

Or when looking at the distribution of values. By changing the `weight` aesthetic to number of people, we are producing the histogram to count bins for the total number of people instead of the total number of counties in each bin.

```{r}
ggplot(midwest, aes(percbelowpoverty)) +
  geom_histogram(binwidth = 1) + 
  ylab("Counties")

ggplot(midwest, aes(percbelowpoverty)) +
  geom_histogram(aes(weight = poptotal), binwidth = 1) +
  ylab("Population (1000s)")
```

## 5.3 Diamonds data

To demonstrate tools for larger datasets, the `diamonds` data will be employed.

![How the variables x,y,z, table and depth are measured in `diamonds` dataset](diamond-dimensions.png)

## 5.4 Displaying distributions

1D continuous distributions

```{r}
ggplot(diamonds,aes(depth))+
  geom_histogram()

ggplot(diamonds,aes(depth))+
  geom_histogram(binwidth=0.1)+
  xlim(55,70)

# Trying a facet_wrap to see different groups distributions (by cut)
ggplot(diamonds,aes(depth))+
  geom_histogram(binwidth = 0.1)+
  xlim(55,70)+
  facet_wrap(~cut)
```

```{r}
# Frequency polygon
ggplot(diamonds, aes(depth)) + 
  geom_freqpoly(aes(colour = cut), binwidth = 0.1, na.rm = TRUE) +
  xlim(58, 68) + 
  theme(legend.position = "none")

# Conditional density plot
# Note that the y-axis is density
ggplot(diamonds, aes(depth)) + 
  geom_histogram(aes(fill = cut), binwidth = 0.1, position = "fill",
    na.rm = TRUE) +
  xlim(58, 68) + 
  theme(legend.position = "none")
```

Note the second plot is a bit more confusing because it scales each group. Both plots use the same statistical transformation: `stat = 'bin'`. Where you get two outputs, `count` and `density` where `count` is default.

$$density = \frac{count}{total count} * bin width$$

`density` is good if you want to compare the shape of the distributions, not the overall size.

An alternative to bin-based visualization of a distribution is a density estimate. `geom_density()` place a little normal distribution at each data point and sums up all the. Use a density plot when the underlying density is smooth, continuous, and unbounded. You can use the `adjust` parameter to make the density more or less smooth.

-   Note the density estimate is standardized to one so information is lost about the relative size of each group.

```{r}
ggplot(diamonds, aes(depth))+
  geom_density(na.rm=TRUE,adjust=0.5) + 
  xlim(58,68)+
  theme(legend.position='none')

ggplot(diamonds,aes(depth,fill=cut,colour=cut))+
  geom_density(alpha=0.2,na.rm=TRUE)+
  xlim(58,68)
```

When comparing many distributions, rather than faceting a bunch.

-   `geom_boxplot()` the box-and-whisker plot shows five summary statistics along with individual 'outliers'. It displays far less info than a histogram, but also takes up less space.

-   `cut_width()` to define how the x variable is broken up into bins.

```{r}
ggplot(diamonds, aes(clarity,depth))+
  geom_boxplot()

ggplot(diamonds, aes(carat,depth))+
  geom_boxplot(aes(group=cut_width(carat,0.1)))+
  xlim(NA,2.05)

```

-   `geom_violin()` is a compacted density plot combined with a boxplot
```{r}
ggplot(diamonds, aes(clarity, depth)) + 
  geom_violin()

ggplot(diamonds, aes(carat, depth)) + 
  geom_violin(aes(group = cut_width(carat, 0.1))) + 
  xlim(NA, 2.05)
```
- `geom_dotplot()` draws one point for each observation which is adjusted in space to avoid overlaps. Only for smaller (observation) datasets. 
```{r}
ggplot(mtcars, aes(x = mpg)) +
  geom_dotplot()
```
### 5.4.1 Exercises
1) What binwidth tells you the most interesting story about the distribution of `carat`? 
```{r}
ggplot(diamonds,aes(carat))+
  geom_histogram(binwidth = 0.01)
```

2) Draw a histogram of `price`. What interesting patterns do you see?
```{r}
ggplot(diamonds,aes(price))+
  geom_histogram(binwidth=5)
# Less diamonds are that expensive. I'm assuming there's a supply/demand price point occuring here. 
```

3) How does the distribution of `price` vary with `clarity`?
```{r}
ggplot(diamonds,aes(price,clarity,fill=clarity))+
  geom_violin()+
  labs(x='Clarity',y='Price')+
  theme_classic()


ggplot(diamonds,aes(price,clarity,fill=clarity))+
  geom_boxplot(outlier.alpha = 0.1,outlier.shape=20)+
  labs(x='Clarity',y='Price')+
  cowplot::theme_minimal_hgrid()+
  theme(axis.line.x = element_blank(), legend.position = 'none')

ggplot(diamonds,aes(price))+
  geom_density()+
  facet_wrap(~clarity)+
  labs(x='Price',y='Distribution Density')

# You can see the price bump and watch it move to the right as you increase in clarity.
```

4) Overlay a frequency polygon and density plot of `depth`. What computed variable do you need to map to `y` to make the two plots comparable? (You can either modify `geom_freqpoly()` or `geom_density()`.)
```{r}
# Cool trick I found online for titles
title = "Overlay of <span style='color:blue;'>Frequency Polygon</span> and <span style='color:orange;'>Density Plot</span> of Depth"

ggplot(diamonds,aes(x=depth))+
  geom_freqpoly(color='green')+
  geom_density(aes(y=after_stat(count)), col = 'orange')+ # Or use ..count.. instead of after_stat()
  labs(title=title,x='Depth',y='Count') +
  theme_minimal()+
  theme(plot.title = element_markdown(title))
```
## 5.5 Dealing with overplotting
*overplotting* is the scenario where you have so many observations in the data and the visualization chosen makes it so the observations are on top of each other and it might obscure what stories might exist in that data source. 

Ways to handle this for different situations are
- Making the points smaller/hollow. 
```{r}
df <- data.frame(x = rnorm(2000), y = rnorm(2000))
norm <- ggplot(df, aes(x, y)) + xlab(NULL) + ylab(NULL)
norm + geom_point()
norm + geom_point(shape = 1) # Hollow circles
norm + geom_point(shape = ".") # Pixel sized
```
- Using alpha (transparency) to reduce some of the visible overlapping occurring
```{r}
norm + geom_point(alpha = 1 / 3)
norm + geom_point(alpha = 1 / 5)
norm + geom_point(alpha = 1 / 10)
```
- Adding jitter (randomness), assuming the data is discrete, will make the number of data points close to a discrete level easier to see with `geom_jitter()`
- Binning the points and counting the number in each bin (think histogram but bin x and y) with `geom_bin2d` or making hexagons with `geom_hex()`
```{r}
norm + geom_bin2d()
norm + geom_bin2d(bins = 10)

norm + geom_hex()
norm + geom_hex(bins = 10)
```

